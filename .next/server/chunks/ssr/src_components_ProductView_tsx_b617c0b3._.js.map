{"version":3,"sources":["../../../../src/components/ProductView.tsx","../../../../node_modules/%40portabletext/toolkit/src/asserters.ts","../../../../node_modules/%40portabletext/react/src/components/list.tsx","../../../../node_modules/%40portabletext/react/src/components/marks.tsx","../../../../node_modules/%40portabletext/toolkit/src/sortMarksByOccurences.ts","../../../../node_modules/%40portabletext/react/src/warnings.ts","../../../../node_modules/%40portabletext/react/src/components/unknown.tsx","../../../../node_modules/%40portabletext/react/src/components/defaults.tsx","../../../../node_modules/%40portabletext/toolkit/src/buildMarksTree.ts","../../../../node_modules/%40portabletext/react/src/components/merge.ts","../../../../node_modules/%40portabletext/react/src/react-portable-text.tsx","../../../../node_modules/%40portabletext/toolkit/src/nestLists.ts","../../../../node_modules/%40portabletext/toolkit/src/spanToPlainText.ts","../../../../node_modules/%40portabletext/toolkit/src/toPlainText.ts","../../../../node_modules/%40portabletext/toolkit/src/types.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState, useCallback } from \"react\";\nimport { urlFor } from \"@/sanity/image\";\nimport { PortableText } from \"@portabletext/react\";\nimport ContactButton from \"@/components/ContactButton\";\nimport ProductCard from \"@/components/ProductCard\";\nimport { ChevronLeft, ChevronRight } from \"lucide-react\";\nimport type { Product } from \"@/interfaces/product\";\nimport useEmblaCarousel from \"embla-carousel-react\";\nimport { useLanguage } from \"@/context/LanguageContext\";\nimport Image from \"next/image\";\n\ninterface ProductViewProps {\n  product: Product;\n  relatedProducts: Product[];\n}\n\nexport default function ProductView({\n  product,\n  relatedProducts,\n}: ProductViewProps) {\n  const { t } = useLanguage();\n  const [selectedImageIndex, setSelectedImageIndex] = useState(0);\n\n  // Embla Carousel setup\n  const [emblaRef, emblaApi] = useEmblaCarousel({ loop: true });\n\n  const onSelect = useCallback(() => {\n    if (!emblaApi) return;\n    setSelectedImageIndex(emblaApi.selectedScrollSnap());\n  }, [emblaApi]);\n\n  useEffect(() => {\n    if (!emblaApi) return;\n    onSelect();\n    emblaApi.on(\"select\", onSelect);\n    emblaApi.on(\"reInit\", onSelect);\n  }, [emblaApi, onSelect]);\n\n  const scrollTo = useCallback(\n    (index: number) => {\n      if (emblaApi) emblaApi.scrollTo(index);\n    },\n    [emblaApi],\n  );\n\n  const scrollPrev = useCallback(() => {\n    if (emblaApi) emblaApi.scrollPrev();\n  }, [emblaApi]);\n\n  const scrollNext = useCallback(() => {\n    if (emblaApi) emblaApi.scrollNext();\n  }, [emblaApi]);\n\n  // Combine main image and additional images\n  const allImages = [\n    product.image,\n    ...(product.images || []).map((img) => img),\n  ].filter(Boolean);\n\n  const formattedPrice = new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n  }).format(product.price);\n\n  return (\n    <div className=\"bg-white min-h-screen pt-20 pb-20 font-roboto\">\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-12 mb-20\">\n          {/* Left: Image Carousel */}\n          <div className=\"space-y-4\">\n            <div className=\"bg-gray-100 rounded-lg relative group\">\n              {/* Embla Viewport */}\n              <div\n                ref={emblaRef}\n                className=\"overflow-hidden rounded-lg aspect-square\"\n              >\n                <div className=\"flex h-full\">\n                  {allImages.map((img, index) => (\n                    <div\n                      className=\"flex-[0_0_100%] min-w-0 relative\"\n                      key={index}\n                    >\n                      <Image\n                        src={urlFor(img).width(800).height(800).url()}\n                        alt={`${product.name} - View ${index + 1}`}\n                        fill\n                        className=\"object-cover\"\n                        priority={index === 0}\n                      />\n                    </div>\n                  ))}\n                </div>\n              </div>\n\n              {/* Navigation Arrows */}\n              {allImages.length > 1 && (\n                <>\n                  <button\n                    onClick={scrollPrev}\n                    className=\"absolute left-4 top-1/2 -translate-y-1/2 bg-white/80 p-2 rounded-full shadow hover:bg-white transition-colors z-10\"\n                    aria-label=\"Previous image\"\n                  >\n                    <ChevronLeft size={24} />\n                  </button>\n                  <button\n                    onClick={scrollNext}\n                    className=\"absolute right-4 top-1/2 -translate-y-1/2 bg-white/80 p-2 rounded-full shadow hover:bg-white transition-colors z-10\"\n                    aria-label=\"Next image\"\n                  >\n                    <ChevronRight size={24} />\n                  </button>\n                </>\n              )}\n            </div>\n            {/* Thumbnails */}\n            {allImages.length > 1 && (\n              <div className=\"flex gap-4 overflow-x-auto pb-2\">\n                {allImages.map((img, idx) => (\n                  <button\n                    key={idx}\n                    onClick={() => scrollTo(idx)}\n                    className={`relative w-20 h-20 flex-shrink-0 rounded-md overflow-hidden border-2 transition-all ${\n                      selectedImageIndex === idx\n                        ? \"border-primary-600 ring-2 ring-primary-100\"\n                        : \"border-transparent hover:border-gray-300\"\n                    }`}\n                  >\n                    <Image\n                      src={urlFor(img).width(100).height(100).url()}\n                      alt={`View ${idx + 1}`}\n                      fill\n                      className=\"object-cover\"\n                    />\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Right: Product Info */}\n          <div>\n            <h1 className=\"text-4xl font-doto font-bold text-gray-900 mb-2\">\n              {product.name}\n            </h1>\n            <p className=\"text-2xl font-bold text-primary-600 mb-6\">\n              {formattedPrice}\n            </p>\n\n            <div className=\"prose prose-neutral max-w-none mb-8 font-roboto text-gray-600\">\n              {product.body && <PortableText value={product.body} />}\n            </div>\n\n            {/* Details Grid */}\n            <div className=\"grid grid-cols-2 gap-x-4 gap-y-6 mb-8 text-sm\">\n              {product.process && (\n                <div>\n                  <span className=\"block text-gray-500 font-medium mb-1\">\n                    {t.product.process}\n                  </span>\n                  <span className=\"font-semibold text-gray-900\">\n                    {product.process}\n                  </span>\n                </div>\n              )}\n              {product.roastLevel && (\n                <div>\n                  <span className=\"block text-gray-500 font-medium mb-1\">\n                    {t.product.roastLevel}\n                  </span>\n                  <span className=\"font-semibold text-gray-900\">\n                    {product.roastLevel}\n                  </span>\n                </div>\n              )}\n              {product.producer && (\n                <div>\n                  <span className=\"block text-gray-500 font-medium mb-1\">\n                    {t.product.producer}\n                  </span>\n                  <span className=\"font-semibold text-gray-900\">\n                    {product.producer}\n                  </span>\n                </div>\n              )}\n              {product.altitude && (\n                <div>\n                  <span className=\"block text-gray-500 font-medium mb-1\">\n                    {t.product.altitude}\n                  </span>\n                  <span className=\"font-semibold text-gray-900\">\n                    {product.altitude}\n                  </span>\n                </div>\n              )}\n            </div>\n\n            <ContactButton\n              className=\"w-full justify-center\"\n              message={`Hi, I'm interested in buying ${product.name}`}\n            />\n          </div>\n        </div>\n\n        {/* Related Products */}\n        {relatedProducts.length > 0 && (\n          <div>\n            <h2 className=\"text-2xl font-doto font-bold mb-8\">\n              {t.product.related}\n            </h2>\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8\">\n              {relatedProducts.map((rp) => (\n                <ProductCard key={rp._id} product={rp} />\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  // oxlint-disable-next-line no-console\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\n\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\n\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  const {\n    block: _block,\n    list: _list,\n    listItem: _listItem,\n    marks: _marks,\n    types: _types,\n    ...rest\n  } = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  function renderListItem(node: PortableTextListItemBlock, index: number, key: string) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: 'listStyle',\n        type: style,\n      })\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child,\n        index: childIndex,\n        isInline: true,\n        renderNode,\n      }),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {\n        nodeType: 'mark',\n        type: markType,\n      })\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({\n      node,\n      index,\n      isInline,\n      renderNode,\n    })\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: 'block',\n      type: node._type,\n    })\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // oxlint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import type {ToolkitNestedPortableTextSpan} from './types'\n\nimport {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem extends PortableTextListItemBlock<\n  PortableTextMarkDefinition,\n  PortableTextSpan | ToolkitPortableTextList\n> {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (ToolkitTextNode | ToolkitNestedPortableTextSpan | ArbitraryTypedObject)[]\n}\n"],"names":["defaultLists: Record<'number' | 'bullet', PortableTextListComponent>","DefaultListItem: PortableTextListItemComponent","link: PortableTextMarkComponent<DefaultLink>","defaultMarks: Record<string, PortableTextMarkComponent | undefined>","defaultComponents: PortableTextReactComponents","occurences: Record<string, number>","rootNode: ToolkitNestedPortableTextSpan<M>","nodeStack: ToolkitNestedPortableTextSpan<M>[]","node: ToolkitNestedPortableTextSpan<M>","tree: ToolkitNestListsOutputNode<T>[]","currentList: ToolkitPortableTextList | undefined","newLastChild: ToolkitPortableTextListItem"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14]}